<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Encrypt to PNG on A → Decrypt on B</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
  <style>
    html, body { 
      height: 100%; 
      margin: 0; 
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #0f1216;
      color: #e5e7eb;
    }
    
    .container {
      max-width: 560px;
      margin: 40px auto;
      padding: 24px;
    }
    
    .title {
      font-size: 22px;
      font-weight: 800;
      margin-bottom: 12px;
    }
    .subtitle { color: #9ca3af; font-size: 13px; margin-bottom: 20px; }
    
    .card {
      background: #12171d;
      border: 1px solid #263241;
      border-radius: 12px;
      padding: 20px;
    }
    
    .form-group { 
      margin-bottom: 16px; 
      text-align: left; 
    }
    
    .form-group label { 
      display: block; 
      margin-bottom: 8px; 
      color: #e2e8f0; 
      font-weight: 500; 
      font-size: 14px; 
    }
    
    .form-group input, select {
      width: 100%; 
      padding: 12px; 
      border: 1px solid #3a4758;
      background: #0f141a;
      border-radius: 8px;
      font-size: 14px; 
      box-sizing: border-box;
      transition: all 0.2s ease;
      color: #f8fafc;
      font-family: inherit;
    }
    .form-group input:focus, select:focus { border-color: #14b8a6; outline: none; }
    
    button { 
      width: 100%; 
      padding: 12px; 
      background: linear-gradient(135deg, #14b8a6 0%, #0d9488 100%);
      color: white; 
      border: none; 
      border-radius: 8px; 
      font-size: 15px; 
      font-weight: 600;
      cursor: pointer; 
      transition: all 0.2s ease; 
      margin-top: 12px;
      font-family: inherit;
    }
    button:hover { opacity: 0.95; }
    button:disabled { opacity: 0.6; cursor: not-allowed; }
    
    .preview { 
      margin-top: 16px; 
      max-width: 100%; 
      max-height: 200px;
      border: 1px solid #263241;
      border-radius: 8px; 
      display: none;
    }
    
    .status { margin-top: 12px; font-size: 13px; }
    
    .hint { color: #9ca3af; font-size: 12px; margin-top: 8px; }
    
    @media (max-width: 768px) { .container { margin: 20px auto; padding: 16px; } }
  </style>
</head>
<body>
  <div class="container">
    <div class="title">Encrypt on Device A → Decrypt on Device B</div>
    <div class="subtitle">Only the PNG and your password are needed on Device B. No extra files.</div>
    <div class="card">
      <div class="form-group">
        <label for="mode">Select Operation:</label>
        <select id="mode">
          <option value="">-- Choose Mode --</option>
          <option value="encrypt">🔒 Encrypt (output: encrypted PNG)</option>
          <option value="decrypt">🔓 Decrypt (restore original file)</option>
        </select>
      </div>
      <div class="form-group">
        <label for="fileInput" id="fileLabel">Upload File to Encrypt:</label>
        <input type="file" id="fileInput" accept="*/*">
        <div class="hint">Device A: choose any file (e.g., test.pdf, song.mp3). Output is PNG.</div>
      </div>
      <div class="form-group">
        <label for="key">Secret Password:</label>
        <input type="password" id="key" placeholder="Enter your secret password">
        <div class="hint">Use the same password on Device B to decrypt from the PNG.</div>
      </div>
      <button id="goBtn">Process</button>
      <img id="preview" class="preview" />
      <div id="status" class="status"></div>
      <canvas id="canvas" style="display:none;"></canvas>
    </div>
  </div>

<script>
/* ======== Crypto Helpers ======== */
function uaToWordArray(u8) {
  const words = [];
  for (let i = 0; i < u8.length; i += 4) {
    words.push(((u8[i]||0)<<24)|((u8[i+1]||0)<<16)|((u8[i+2]||0)<<8)|((u8[i+3]||0)));
  }
  return CryptoJS.lib.WordArray.create(words, u8.length);
}

function wordArrayToUa(w) {
  const {words,sigBytes} = w;
  const u8 = new Uint8Array(sigBytes);
  for (let i = 0; i < sigBytes; i++) {
    u8[i] = (words[i>>>2] >> (24-(i%4)*8)) & 0xff;
  }
  return u8;
}

function generateSubstitutionTable(password, salt, imageHash, rounds = 3) {
  const combined = password + salt + imageHash;
  const hash = CryptoJS.SHA256(combined).toString();
  
  // Initialize substitution table with identity mapping
  const table = new Uint8Array(256);
  for (let i = 0; i < 256; i++) {
    table[i] = i;
  }
  
  // Shuffle table based on hash with multiple rounds for security
  for (let round = 0; round < rounds; round++) {
    const roundHash = CryptoJS.SHA256(hash + round + imageHash).toString();
    
    for (let i = 0; i < 256; i++) {
      // Use hash bytes to determine swap positions
      const hashIndex = (i * 2) % roundHash.length;
      const swapIndex = parseInt(roundHash.substr(hashIndex, 2), 16);
      
      // Swap current position with hash-determined position
      const temp = table[i];
      table[i] = table[swapIndex];
      table[swapIndex] = temp;
    }
  }
  
  return table;
}

function generateReverseTable(substitutionTable) {
  const reverseTable = new Uint8Array(256);
  for (let i = 0; i < 256; i++) {
    reverseTable[substitutionTable[i]] = i;
  }
  return reverseTable;
}

function monoalphabeticEncrypt(data, substitutionTable) {
  const encrypted = new Uint8Array(data.length);
  for (let i = 0; i < data.length; i++) {
    encrypted[i] = substitutionTable[data[i]];
  }
  return encrypted;
}

function monoalphabeticDecrypt(data, reverseTable) {
  const decrypted = new Uint8Array(data.length);
  for (let i = 0; i < data.length; i++) {
    decrypted[i] = reverseTable[data[i]];
  }
  return decrypted;
}

function setStatus(msg, type = 'info'){ 
  const statusEl = document.getElementById("status");
  if (type === 'loading') {
    statusEl.innerHTML = `<span class="loading-spinner"></span>${msg}`;
    statusEl.className = 'status info';
  } else {
    statusEl.textContent = msg;
    statusEl.className = `status ${type}`;
  }
}

function downloadBlob(blob, filename){ 
  const a = document.createElement("a"); 
  a.href = URL.createObjectURL(blob); 
  a.download = filename; 
  a.click(); 
  URL.revokeObjectURL(a.href);
}

function encryptedDataToPNG(encryptedData) {
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  
  // Calculate canvas dimensions (square-ish)
  const dataLength = encryptedData.length;
  const width = Math.ceil(Math.sqrt(dataLength / 3)); // 3 bytes per pixel (RGB)
  const height = Math.ceil(dataLength / (width * 3));
  
  canvas.width = width;
  canvas.height = height;
  
  // Create image data
  const imageData = ctx.createImageData(width, height);
  const pixels = imageData.data;
  
  let dataIndex = 0;
  for (let i = 0; i < pixels.length; i += 4) {
    if (dataIndex < dataLength) {
      pixels[i] = encryptedData[dataIndex++];     // R
    } else {
      pixels[i] = Math.floor(Math.random() * 256); // R (random noise)
    }
    
    if (dataIndex < dataLength) {
      pixels[i + 1] = encryptedData[dataIndex++]; // G
    } else {
      pixels[i + 1] = Math.floor(Math.random() * 256); // G (random noise)
    }
    
    if (dataIndex < dataLength) {
      pixels[i + 2] = encryptedData[dataIndex++]; // B
    } else {
      pixels[i + 2] = Math.floor(Math.random() * 256); // B (random noise)
    }
    
    pixels[i + 3] = 255; // A (always fully opaque)
  }
  
  ctx.putImageData(imageData, 0, 0);
  
  return new Promise(resolve => {
    canvas.toBlob(resolve, 'image/png');
  });
}

async function pngToEncryptedData(file) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = "anonymous";
    
    img.onload = () => {
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      
      canvas.width = img.width;
      canvas.height = img.height;
      ctx.drawImage(img, 0, 0);
      
      const imageData = ctx.getImageData(0, 0, img.width, img.height);
      const pixels = imageData.data;
      
      const rgbData = [];
      for (let i = 0; i < pixels.length; i += 4) {
        rgbData.push(pixels[i]);     // R
        rgbData.push(pixels[i + 1]); // G
        rgbData.push(pixels[i + 2]); // B
        // Skip alpha channel (pixels[i + 3])
      }
      
      if (rgbData.length < 110) {
        reject(new Error("Invalid encrypted file header"));
        return;
      }
      // filenameLen (2 bytes) + cipherLen (4 bytes)
      const filenameLen = (rgbData[104] << 8) | rgbData[105];
      const cipherDataLength = (rgbData[106] << 24) | (rgbData[107] << 16) | (rgbData[108] << 8) | rgbData[109];
      const totalDataLength = 110 + filenameLen + cipherDataLength;
      
      // Validate data length
      if (totalDataLength > rgbData.length || cipherDataLength <= 0) {
        reject(new Error("Corrupted encrypted file - invalid data length"));
        return;
      }
      
      const encryptedData = new Uint8Array(totalDataLength);
      for (let i = 0; i < totalDataLength; i++) {
        encryptedData[i] = rgbData[i];
      }
      
      resolve(encryptedData);
    };
    
    img.onerror = () => reject(new Error("Failed to load image"));
    img.src = URL.createObjectURL(file);
  });
}

/* ======== Enhanced Monoalphabetic File Encryption ======== */
async function encryptFile(file, password){
  const arrayBuffer = await file.arrayBuffer();
  const plain = new Uint8Array(arrayBuffer);

  const imageHashWords = CryptoJS.SHA256(CryptoJS.lib.WordArray.create(plain));
  const imageHash = imageHashWords.toString();

  // Generate cryptographically secure salt
  const saltWords = CryptoJS.lib.WordArray.random(16);
  const salt = wordArrayToUa(saltWords);
  const saltString = Array.from(salt).map(b => b.toString(16).padStart(2, '0')).join('');

  const substitutionTable = generateSubstitutionTable(password, saltString, imageHash, 5);
  
  // Apply monoalphabetic encryption with multiple passes for security
  let encrypted = new Uint8Array(plain);
  for (let pass = 0; pass < 3; pass++) {
    const passTable = generateSubstitutionTable(password + pass, saltString, imageHash, 3);
    encrypted = monoalphabeticEncrypt(encrypted, passTable);
  }

  const MAGIC = new TextEncoder().encode("MONOIMG1");
  const originalType = new TextEncoder().encode((file.type || 'application/octet-stream').padEnd(16, '\0').substring(0, 16));
  
  const encoder = new TextEncoder();
  let filenameBytes = encoder.encode(file.name || 'file');
  if (filenameBytes.length > 65535) filenameBytes = filenameBytes.slice(0, 65535);
  const filenameLen = filenameBytes.length;

  const imageHashBytes = new TextEncoder().encode(imageHash.padEnd(64, '\0').substring(0, 64));
  const header = new Uint8Array(8 + 16 + 16 + 64 + 2 + 4); // + filenameLen(2) + cipherLen(4)
  header.set(MAGIC, 0);
  header.set(originalType, 8);
  header.set(salt, 24);
  header.set(imageHashBytes, 40);
  
  // filename length (2 bytes, BE)
  header[104] = (filenameLen >> 8) & 0xFF;
  header[105] = filenameLen & 0xFF;
  // cipher length (4 bytes, BE)
  const lengthBytes = new Uint8Array(4);
  lengthBytes[0] = (encrypted.length >> 24) & 0xFF;
  lengthBytes[1] = (encrypted.length >> 16) & 0xFF;
  lengthBytes[2] = (encrypted.length >> 8) & 0xFF;
  lengthBytes[3] = encrypted.length & 0xFF;
  header.set(lengthBytes, 106);

  // Combine header + filename + encrypted data
  const encryptedData = new Uint8Array(header.length + filenameBytes.length + encrypted.length);
  encryptedData.set(header, 0);
  encryptedData.set(filenameBytes, header.length);
  encryptedData.set(encrypted, header.length + filenameBytes.length);

  return await encryptedDataToPNG(encryptedData);
}

/* ======== Enhanced Monoalphabetic File Decryption ======== */
async function decryptFile(file, password){
  try {
    const encryptedData = await pngToEncryptedData(file);
    
    if (encryptedData.length < 110) {
      throw new Error("❌ Invalid encrypted file - file too small or corrupted");
    }
    
    // Verify magic header for monoalphabetic format
    const MAGIC = new TextEncoder().encode("MONOIMG1");
    for(let i = 0; i < MAGIC.length; i++){ 
      if(encryptedData[i] !== MAGIC[i]) {
        throw new Error("❌ This is not a valid monoalphabetic encrypted image file. Please select a PNG file that was encrypted by this app."); 
      }
    }

    const originalTypeBytes = encryptedData.slice(8, 24);
    const originalType = new TextDecoder().decode(originalTypeBytes).replace(/\0/g, '');
    
    const salt = encryptedData.slice(24, 40);
    const saltString = Array.from(salt).map(b => b.toString(16).padStart(2, '0')).join('');
    
    const imageHashBytes = encryptedData.slice(40, 104);
    const imageHash = new TextDecoder().decode(imageHashBytes).replace(/\0/g, '');
    
    // Read filename length and cipher data length
    const filenameLen = (encryptedData[104] << 8) | encryptedData[105];
    const cipherLength = (encryptedData[106] << 24) | (encryptedData[107] << 16) | (encryptedData[108] << 8) | encryptedData[109];
    const nameStart = 110;
    const nameEnd = 110 + filenameLen;
    const filenameBytes = encryptedData.slice(nameStart, nameEnd);
    const originalName = new TextDecoder().decode(filenameBytes);
    const cipherBytes = encryptedData.slice(nameEnd, nameEnd + cipherLength);

    if (cipherBytes.length === 0 || cipherBytes.length !== cipherLength) {
      throw new Error("❌ Corrupted encrypted file - cipher data mismatch");
    }

    // Apply reverse monoalphabetic decryption (3 passes in reverse order)
    let decrypted = new Uint8Array(cipherBytes);
    for (let pass = 2; pass >= 0; pass--) {
      const passTable = generateSubstitutionTable(password + pass, saltString, imageHash, 3);
      const reverseTable = generateReverseTable(passTable);
      decrypted = monoalphabeticDecrypt(decrypted, reverseTable);
    }
    
    if (decrypted.length === 0) {
      throw new Error("🔑 Wrong password - unable to decrypt image data");
    }
    
    const blob = new Blob([decrypted], { type: originalType || "application/octet-stream" });
    return { blob, filename: originalName || "output" };
    
  } catch (error) {
    if (error.message.includes("Invalid encrypted file") || error.message.includes("monoalphabetic")) {
      throw new Error("❌ This is not a valid monoalphabetic encrypted image file. Please select a PNG file that was encrypted by this app.");
    } else if (error.message.includes("Wrong password")) {
      throw new Error("🔑 Incorrect password! Please check your password and try again.");
    } else if (error.message.includes("Corrupted")) {
      throw new Error("💥 The encrypted file appears to be corrupted or damaged. Try re-encrypting the original image.");
    } else {
      throw new Error(`❌ Decryption failed: ${error.message}`);
    }
  }
}

/* ======== UI Event Handlers ======== */
const modeSel = document.getElementById("mode");
const fileInput = document.getElementById("fileInput");
const keyInput = document.getElementById("key");
const goBtn = document.getElementById("goBtn");
const preview = document.getElementById("preview");
const centralToggle = document.getElementById('centralToggle');
const turnOnDiv = document.getElementById('turnon');
let lightsOn = false;

// Minimal UI: removed lamp/toggle

goBtn.addEventListener("click", async () => {
  const mode = modeSel.value;
  const file = fileInput.files[0];
  const password = keyInput.value;

  // Validation
  if(!mode) { setStatus("⚠️ Please select an operation mode", "warning"); return; }
  if(!file) { setStatus("⚠️ Please upload a file", "warning"); return; }
  if(!password) { setStatus("⚠️ Please enter a secret password", "warning"); return; }
  if(password.length < 6) { setStatus("⚠️ Password must be at least 6 characters", "warning"); return; }

  goBtn.disabled = true;
  preview.style.display = "none";

  try {
    if(mode === "encrypt") {
      setStatus("🔒 Encrypting your file...", "loading");
      const startTime = Date.now();
      
      const encryptedBlob = await encryptFile(file, password);
      const duration = ((Date.now() - startTime) / 1000).toFixed(1);
      
      preview.src = URL.createObjectURL(encryptedBlob);
      preview.style.display = "block";
      preview.style.imageRendering = "pixelated"; // Show encrypted noise pattern clearly
      preview.style.border = "2px solid rgba(255, 235, 131, 0.3)"; // Golden border for encrypted images
      
      const fileSizeKB = (encryptedBlob.size / 1024).toFixed(1);
      setStatus(`✅ File encrypted successfully in ${duration}s! Encrypted as PNG (${fileSizeKB}KB).`, "success");
      downloadBlob(encryptedBlob, `encrypted_${file.name.split('.')[0]}.png`);
      
    } else if(mode === "decrypt") {
      setStatus("🔓 Decrypting your file...", "loading");
      const startTime = Date.now();
      
      const { blob: decryptedBlob, filename: originalName } = await decryptFile(file, password);
      const duration = ((Date.now() - startTime) / 1000).toFixed(1);
      
      if ((decryptedBlob.type || '').startsWith('image/')) {
        preview.src = URL.createObjectURL(decryptedBlob);
        preview.style.display = "block";
        preview.style.imageRendering = "auto"; // Smooth rendering for original images
        preview.style.border = "2px solid rgba(72, 187, 120, 0.3)"; // Green border for decrypted images
      } else {
        preview.style.display = "none";
      }
      
      const fileSizeKB = (decryptedBlob.size / 1024).toFixed(1);
      setStatus(`🎉 File decrypted successfully in ${duration}s! Original restored (${fileSizeKB}KB).`, "success");
      downloadBlob(decryptedBlob, originalName);
    }
  } catch(err) {
    console.error("Encryption/Decryption error:", err);
    setStatus(err?.message || "❌ Operation failed - please try again", "error");
    preview.style.display = "none";
  } finally {
    goBtn.disabled = false;
  }
});

// Dynamic label updates
modeSel.addEventListener("change", () => {
  const label = document.getElementById("fileLabel");
  keyInput.value = ""; // Clear secret password
  fileInput.value = ""; // Clear file upload
  preview.style.display = "none"; // Hide preview
  document.getElementById("status").textContent = ""; // Clear status
  
  if(modeSel.value === "encrypt") {
    label.textContent = "Upload File to Encrypt:";
    fileInput.accept = "*/*";
  } else if(modeSel.value === "decrypt") {
    label.textContent = "Upload Encrypted PNG Image:";
    fileInput.accept = ".png,image/png";
  } else {
    label.textContent = "Upload File:";
    fileInput.accept = "*/*";
  }
});

// File drag and drop support
['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
  fileInput.addEventListener(eventName, preventDefaults, false);
});

function preventDefaults(e) {
  e.preventDefault();
  e.stopPropagation();
}

fileInput.addEventListener('drop', handleDrop, false);

function handleDrop(e) {
  const dt = e.dataTransfer;
  const files = dt.files;
  fileInput.files = files;
}
</script>

</body>
</html>
