<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Image Encryption Lamp Demo (Secure PNG)</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
  <style>
    html, body { 
      overflow: hidden; 
      height: 100%; 
      margin: 0; 
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 25%, #2d2d2d 50%, #1a1a1a 75%, #0a0a0a 100%);
      background-size: 400% 400%;
      animation: subtleShift 15s ease infinite;
    }
    
    @keyframes subtleShift {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }
    
    /* Geometric floating shapes instead of particles */
    #turnon::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image: 
        radial-gradient(circle at 15% 25%, rgba(20, 184, 166, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 85% 75%, rgba(251, 146, 60, 0.08) 0%, transparent 50%),
        radial-gradient(circle at 45% 60%, rgba(20, 184, 166, 0.05) 0%, transparent 40%);
      animation: floatShapes 20s ease-in-out infinite;
      pointer-events: none;
    }
    
    @keyframes floatShapes {
      0%, 100% { transform: translateY(0px) rotate(0deg); opacity: 0.3; }
      33% { transform: translateY(-20px) rotate(120deg); opacity: 0.6; }
      66% { transform: translateY(10px) rotate(240deg); opacity: 0.4; }
    }
    
    #turnon { 
      width: 100%; 
      height: 100%; 
      display: block; 
      background: 
        radial-gradient(circle at 30% 70%, rgba(20, 184, 166, 0.03) 0%, transparent 50%),
        radial-gradient(circle at 70% 30%, rgba(251, 146, 60, 0.03) 0%, transparent 50%),
        linear-gradient(135deg, rgba(10, 10, 10, 0.95) 0%, rgba(26, 26, 26, 0.95) 100%);
      position: relative;
    }
    
    /* Modern geometric lamp design with teal accent */
    .lamp, .turnoff {
      width: 60px; 
      height: 60px; 
      top: 20px; 
      left: 50%; 
      margin-left: -30px;
      position: absolute; 
      border-bottom: 60px solid #14b8a6;
      border-left: 30px solid transparent; 
      border-right: 30px solid transparent;
      height: 0; 
      z-index: 11; 
      cursor: pointer; 
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      filter: drop-shadow(0 4px 20px rgba(20, 184, 166, 0.3));
    }
    
    .lamp:hover { 
      border-bottom-color: #0d9488;
      transform: scale(1.05) translateY(-2px);
      filter: drop-shadow(0 6px 25px rgba(20, 184, 166, 0.4));
    }
    
    .turnoff { 
      display: none; 
      border-bottom-color: #fb923c;
    } 
    
    .turnoff:hover { 
      border-bottom-color: #f97316;
    }
    
    /* Sleek modern bulb with orange glow */
    .bulb { 
      position: absolute; 
      top: 90px; 
      left: 50%; 
      height: 20px; 
      width: 20px;
      margin-left: -10px; 
      background: linear-gradient(135deg, #374151, #4b5563, #6b7280);
      border-radius: 50%; 
      z-index: 9; 
      transition: all 0.3s ease;
      box-shadow: 
        0 2px 10px rgba(0,0,0,0.3),
        inset 0 1px 2px rgba(255,255,255,0.1);
    }
    
    /* Minimal string design */
    .string { 
      position: absolute; 
      top: 90px; 
      left: 50%; 
      margin-left: 15px;
      height: 60px; 
      width: 1px; 
      background: #4b5563;
      display: block; 
      z-index: 10;
    }
    
    /* Add illumination effect that spreads downward */
    .illumination {
      position: absolute;
      top: 120px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      background: radial-gradient(ellipse at center top, 
        rgba(251, 146, 60, 0.15) 0%, 
        rgba(251, 146, 60, 0.08) 30%, 
        rgba(251, 146, 60, 0.03) 60%, 
        transparent 100%);
      border-radius: 50%;
      opacity: 0;
      transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 5;
      pointer-events: none;
    }
    
    /* Clean typography with teal accent */
    .login-text { 
      position: absolute; 
      top: 45%; 
      left: 50%; 
      transform: translateX(-50%);
      color: #f8fafc; 
      font-size: 32px; 
      font-weight: 800; 
      z-index: 12; 
      transition: all 0.6s ease; 
      pointer-events: none; 
      letter-spacing: 4px;
      text-align: center;
      opacity: 0;
    }
    
    .subtitle {
      display: block;
      font-size: 14px;
      font-weight: 400;
      margin-top: 16px;
      opacity: 0.7;
      letter-spacing: 2px;
      color: #94a3b8;
      font-family: 'SF Mono', 'Monaco', 'Cascadia Code', monospace;
    }
    
    /* Modern card design with subtle borders */
    .login-form { 
      position: absolute; 
      top: 65%; 
      left: 50%; 
      transform: translate(-50%, -50%) translateY(30px);
      background: rgba(26, 26, 26, 0.95);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(75, 85, 99, 0.3);
      padding: 40px; 
      border-radius: 16px;
      box-shadow: 
        0 20px 40px rgba(0,0,0,0.4),
        0 1px 0 rgba(255,255,255,0.05); 
      opacity: 0; 
      visibility: hidden;
      transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1); 
      z-index: 15; 
      width: 420px; 
      text-align: center;
    }
    
    .login-form h2 { 
      color: #f8fafc;
      margin-bottom: 12px; 
      font-size: 24px;
      font-weight: 700;
      letter-spacing: 1px;
    }

    .login-form p.explain {
      color: #cbd5e1;
      font-size: 13px;
      margin-bottom: 18px;
      opacity: 0.9;
    }
    
    .form-group { 
      margin-bottom: 24px; 
      text-align: left; 
    }
    
    .form-group label { 
      display: block; 
      margin-bottom: 8px; 
      color: #e2e8f0; 
      font-weight: 500; 
      font-size: 14px; 
    }
    
    /* Clean input design with teal focus states */
    .form-group input, select {
      width: 100%; 
      padding: 16px; 
      border: 1px solid #374151;
      background: rgba(17, 17, 17, 0.8);
      border-radius: 8px;
      font-size: 14px; 
      box-sizing: border-box;
      transition: all 0.2s ease;
      color: #f8fafc;
      font-family: inherit;
    }
    
    .form-group input:focus, select:focus {
      outline: none;
      border-color: #14b8a6;
      background: rgba(17, 17, 17, 0.95);
      box-shadow: 0 0 0 3px rgba(20, 184, 166, 0.1);
    }
    
    .form-group input::placeholder {
      color: #6b7280;
    }
    
    /* Modern button with orange accent */
    button { 
      width: 100%; 
      padding: 16px; 
      background: linear-gradient(135deg, #fb923c 0%, #f97316 100%);
      color: white; 
      border: none; 
      border-radius: 8px; 
      font-size: 16px; 
      font-weight: 600;
      cursor: pointer; 
      transition: all 0.2s ease; 
      margin-top: 24px;
      font-family: inherit;
    }
    
    button:hover { 
      background: linear-gradient(135deg, #f97316 0%, #ea580c 100%);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(251, 146, 60, 0.3);
    }
    
    /* Clean preview styling */
    .preview { 
      margin-top: 24px; 
      max-width: 100%; 
      max-height: 200px;
      border: 1px solid #374151;
      border-radius: 8px; 
      display: none;
    }
    
    /* Modern status messages */
    .status { 
      margin-top: 20px; 
      font-size: 14px; 
      font-weight: 500; 
      padding: 12px 16px;
      border-radius: 8px;
      border: 1px solid transparent;
    }
    
    .status.success { 
      background: rgba(34, 197, 94, 0.1); 
      color: #4ade80; 
      border-color: rgba(34, 197, 94, 0.2);
    }
    .status.error { 
      background: rgba(239, 68, 68, 0.1); 
      color: #f87171; 
      border-color: rgba(239, 68, 68, 0.2);
    }
    .status.warning { 
      background: rgba(251, 146, 60, 0.1); 
      color: #fbbf24; 
      border-color: rgba(251, 146, 60, 0.2);
    }
    .status.info { 
      background: rgba(20, 184, 166, 0.1); 
      color: #5eead4; 
      border-color: rgba(20, 184, 166, 0.2);
    }
    
    .loading-spinner {
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid rgba(255,255,255,0.1);
      border-top: 2px solid #14b8a6;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-right: 8px;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    button:disabled {
      background: rgba(75, 85, 99, 0.5) !important;
      color: rgba(255,255,255,0.4) !important;
      cursor: not-allowed !important;
      transform: none !important;
      box-shadow: none !important;
    }
    
    /* Orange bulb glow when activated */
    #turnon.lights-on .bulb { 
      background: linear-gradient(135deg, #fb923c, #f97316);
      box-shadow: 
        0 0 30px rgba(251, 146, 60, 0.8),
        0 0 60px rgba(251, 146, 60, 0.4),
        0 0 90px rgba(251, 146, 60, 0.2);
      transform: scale(1.3);
    }
    
    #turnon.lights-on .login-form { 
      opacity: 1; 
      visibility: visible; 
      transform: translate(-50%, -50%) translateY(0);
    }
    
    #turnon.lights-on .login-text { 
      opacity: 1; 
      transform: translateX(-50%) translateY(0);
    }
    
    #turnon.lights-on .illumination {
      opacity: 1;
      width: 800px;
      height: 600px;
      animation: illuminate 2s ease-out;
    }
    
    #turnon.lights-on .central-toggle {
      animation: none;
    }
    
    /* Central toggle button styles */
    .central-toggle {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, #14b8a6 0%, #0d9488 100%);
      color: white;
      border: none;
      border-radius: 50%;
      width: 80px;
      height: 80px;
      font-size: 24px;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 20;
      box-shadow: 
        0 8px 32px rgba(20, 184, 166, 0.3),
        0 0 0 0 rgba(20, 184, 166, 0.4);
      animation: pulse 2s infinite;
    }
    
    .central-toggle:hover {
      transform: translate(-50%, -50%) scale(1.1);
      box-shadow: 
        0 12px 40px rgba(20, 184, 166, 0.4),
        0 0 0 10px rgba(20, 184, 166, 0.1);
    }
    
    .central-toggle.lights-on {
      background: linear-gradient(135deg, #fb923c 0%, #f97316 100%);
      box-shadow: 
        0 8px 32px rgba(251, 146, 60, 0.3),
        0 0 0 0 rgba(251, 146, 60, 0.4);
      top: auto;
      bottom: 20px;
      transform: translateX(-50%);
    }
    
    .central-toggle.lights-on:hover {
      box-shadow: 
        0 12px 40px rgba(251, 146, 60, 0.4),
        0 0 0 10px rgba(251, 146, 60, 0.1);
      transform: translateX(-50%) scale(1.1);
    }
    
    @keyframes pulse {
      0% { box-shadow: 0 8px 32px rgba(20, 184, 166, 0.3), 0 0 0 0 rgba(20, 184, 166, 0.4); }
      70% { box-shadow: 0 8px 32px rgba(20, 184, 166, 0.3), 0 0 0 10px rgba(20, 184, 166, 0); }
      100% { box-shadow: 0 8px 32px rgba(20, 184, 166, 0.3), 0 0 0 0 rgba(20, 184, 166, 0); }
    }
    
    @keyframes illuminate {
      0% { opacity: 0; }
      100% { opacity: 1; }
    }
    
    @media (max-width: 768px) {
      .login-form { 
        width: 90%; 
        padding: 24px; 
      }
      
      .login-text { 
        font-size: 28px; 
      }
      
      .lamp, .turnoff {
        top: 15%;
      }
      
      .bulb {
        top: calc(15% + 70px);
      }
      
      .string {
        top: calc(15% + 70px);
      }
      
      .central-toggle.lights-on {
        bottom: 15px;
      }
    }
  </style>
</head>
<body>
  <div id="turnon">
    <!-- Re-enable lamp clicking functionality -->
    <div class="lamp" onclick="toggleLights()"></div>
    <div style="
  position: fixed; 
  top: 50%; 
  left: 50%; 
  transform: translate(-50%, -50%); 
  text-align: center;
">
<head>
  <!-- Poppins font -->
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@500;600&display=swap" rel="stylesheet">
  <style>
    .animated-text {
      font-size: 22px;
      font-weight: 600;
      font-family: 'Poppins', sans-serif;
      text-align: center;
      margin-bottom: 18px;
      background: linear-gradient(90deg, #ff7e5f, #feb47b, #ff7e5f);
      background-size: 200% auto;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: shine 3s linear infinite;
    }

    @keyframes shine {
      0% { background-position: 0% center; }
      100% { background-position: 200% center; }
    }
  </style>
</head>

<p class="animated-text">
  To see BATCH -15 CNS Project click button below
</p>


  <button 
    id="centralToggle" 
    style="
      background: linear-gradient(135deg, #fb923c, #f97316);
      color: black;
      padding: 10px 24px;          /* bigger capsule */
      width: fit-content;          
      border-radius: 999px;
      font-size: 18px;             /* bigger text */
      font-weight: 700;
      box-shadow: 0 6px 14px rgba(251, 146, 60, 0.45);
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      white-space: nowrap;
      margin: 0 auto;
    "
  >
    BATCH-15
  </button>
</div>

    
    
    <div class="string"></div>
    <div class="bulb"></div>
    <!-- Add illumination effect element -->
    <div class="illumination"></div>
    
    <div class="login-text">
      IMAGE ENCRYPTION
      <span class="subtitle">Click the button to begin</span>
      <span class="subtitle" style="margin-top:8px; font-weight:600;">Steganography — encrypt on one system, decrypt on another</span>
    </div>
    
    <div class="login-form">
      <h2>🔐 Secure Image Vault</h2>
      <p class="explain">Steganography mode: this app embeds encrypted file bytes inside a PNG so you can encrypt on one machine and safely decrypt on another using the same password. Use the "Encrypt" mode to create the stego-PNG and transfer it to the other system for "Decrypt".</p>
      
      <div class="form-group">
        <label for="mode">Select Operation:</label>
        <select id="mode">
          <option value="">-- Choose Mode --</option>
          <option value="encrypt">🔒 Encrypt (Secure PNG Output)</option>
          <option value="decrypt">🔓 Decrypt (Restore Original)</option>
        </select>
      </div>
      
      <div class="form-group">
        <label for="fileInput" id="fileLabel">Upload Original Image (PNG/JPG):</label>
        <input type="file" id="fileInput" accept=".png,.jpg,.jpeg,image/png,image/jpeg">
      </div>
      
      <div class="form-group">
        <label for="key">Secret Password:</label>
        <input type="password" id="key" placeholder="Enter your secret password">
      </div>
      
      <button id="goBtn">🚀 Process Image</button>
      
      <img id="preview" class="preview" />
      <div id="status" class="status"></div>
      <canvas id="canvas" style="display:none;"></canvas>
    </div>
  </div>

<script>
/* ======== Crypto Helpers ======== */
function uaToWordArray(u8) {
  const words = [];
  for (let i = 0; i < u8.length; i += 4) {
    words.push(((u8[i]||0)<<24)|((u8[i+1]||0)<<16)|((u8[i+2]||0)<<8)|((u8[i+3]||0)));
  }
  return CryptoJS.lib.WordArray.create(words, u8.length);
}

function wordArrayToUa(w) {
  const {words,sigBytes} = w;
  const u8 = new Uint8Array(sigBytes);
  for (let i = 0; i < sigBytes; i++) {
    u8[i] = (words[i>>>2] >> (24-(i%4)*8)) & 0xff;
  }
  return u8;
}

function generateSubstitutionTable(password, salt, imageHash, rounds = 3) {
  const combined = password + salt + imageHash;
  const hash = CryptoJS.SHA256(combined).toString();
  
  // Initialize substitution table with identity mapping
  const table = new Uint8Array(256);
  for (let i = 0; i < 256; i++) {
    table[i] = i;
  }
  
  // Shuffle table based on hash with multiple rounds for security
  for (let round = 0; round < rounds; round++) {
    const roundHash = CryptoJS.SHA256(hash + round + imageHash).toString();
    
    for (let i = 0; i < 256; i++) {
      // Use hash bytes to determine swap positions
      const hashIndex = (i * 2) % roundHash.length;
      const swapIndex = parseInt(roundHash.substr(hashIndex, 2), 16);
      
      // Swap current position with hash-determined position
      const temp = table[i];
      table[i] = table[swapIndex];
      table[swapIndex] = temp;
    }
  }
  
  return table;
}

function generateReverseTable(substitutionTable) {
  const reverseTable = new Uint8Array(256);
  for (let i = 0; i < 256; i++) {
    reverseTable[substitutionTable[i]] = i;
  }
  return reverseTable;
}

function monoalphabeticEncrypt(data, substitutionTable) {
  const encrypted = new Uint8Array(data.length);
  for (let i = 0; i < data.length; i++) {
    encrypted[i] = substitutionTable[data[i]];
  }
  return encrypted;
}

function monoalphabeticDecrypt(data, reverseTable) {
  const decrypted = new Uint8Array(data.length);
  for (let i = 0; i < data.length; i++) {
    decrypted[i] = reverseTable[data[i]];
  }
  return decrypted;
}

function setStatus(msg, type = 'info'){ 
  const statusEl = document.getElementById("status");
  if (type === 'loading') {
    statusEl.innerHTML = `<span class="loading-spinner"></span>${msg}`;
    statusEl.className = 'status info';
  } else {
    statusEl.textContent = msg;
    statusEl.className = `status ${type}`;
  }
}

function downloadBlob(blob, filename){ 
  const a = document.createElement("a"); 
  a.href = URL.createObjectURL(blob); 
  a.download = filename; 
  a.click(); 
  URL.revokeObjectURL(a.href);
}

function encryptedDataToPNG(encryptedData) {
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  
  // Calculate canvas dimensions (square-ish)
  const dataLength = encryptedData.length;
  const width = Math.ceil(Math.sqrt(dataLength / 3)); // 3 bytes per pixel (RGB)
  const height = Math.ceil(dataLength / (width * 3));
  
  canvas.width = width;
  canvas.height = height;
  
  // Create image data
  const imageData = ctx.createImageData(width, height);
  const pixels = imageData.data;
  
  let dataIndex = 0;
  for (let i = 0; i < pixels.length; i += 4) {
    if (dataIndex < dataLength) {
      pixels[i] = encryptedData[dataIndex++];     // R
    } else {
      pixels[i] = Math.floor(Math.random() * 256); // R (random noise)
    }
    
    if (dataIndex < dataLength) {
      pixels[i + 1] = encryptedData[dataIndex++]; // G
    } else {
      pixels[i + 1] = Math.floor(Math.random() * 256); // G (random noise)
    }
    
    if (dataIndex < dataLength) {
      pixels[i + 2] = encryptedData[dataIndex++]; // B
    } else {
      pixels[i + 2] = Math.floor(Math.random() * 256); // B (random noise)
    }
    
    pixels[i + 3] = 255; // A (always fully opaque)
  }
  
  ctx.putImageData(imageData, 0, 0);
  
  return new Promise(resolve => {
    canvas.toBlob(resolve, 'image/png');
  });
}

async function pngToEncryptedData(file) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = "anonymous";
    
    img.onload = () => {
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      
      canvas.width = img.width;
      canvas.height = img.height;
      ctx.drawImage(img, 0, 0);
      
      const imageData = ctx.getImageData(0, 0, img.width, img.height);
      const pixels = imageData.data;
      
      const rgbData = [];
      for (let i = 0; i < pixels.length; i += 4) {
        rgbData.push(pixels[i]);     // R
        rgbData.push(pixels[i + 1]); // G
        rgbData.push(pixels[i + 2]); // B
        // Skip alpha channel (pixels[i + 3])
      }
      
      if (rgbData.length < 108) {
        reject(new Error("Invalid encrypted file header"));
        return;
      }
      
      const cipherDataLength = (rgbData[104] << 24) | (rgbData[105] << 16) | (rgbData[106] << 8) | rgbData[107];
      const totalDataLength = 108 + cipherDataLength; // Updated header size
      
      // Validate data length
      if (totalDataLength > rgbData.length || cipherDataLength <= 0) {
        reject(new Error("Corrupted encrypted file - invalid data length"));
        return;
      }
      
      const encryptedData = new Uint8Array(totalDataLength);
      for (let i = 0; i < totalDataLength; i++) {
        encryptedData[i] = rgbData[i];
      }
      
      resolve(encryptedData);
    };
    
    img.onerror = () => reject(new Error("Failed to load image"));
    img.src = URL.createObjectURL(file);
  });
}

/* ======== Enhanced Monoalphabetic File Encryption ======== */
async function encryptFile(file, password){
  const arrayBuffer = await file.arrayBuffer();
  const plain = new Uint8Array(arrayBuffer);

  const imageHashWords = CryptoJS.SHA256(CryptoJS.lib.WordArray.create(plain));
  const imageHash = imageHashWords.toString();

  // Generate cryptographically secure salt
  const saltWords = CryptoJS.lib.WordArray.random(16);
  const salt = wordArrayToUa(saltWords);
  const saltString = Array.from(salt).map(b => b.toString(16).padStart(2, '0')).join('');

  const substitutionTable = generateSubstitutionTable(password, saltString, imageHash, 5);
  
  // Apply monoalphabetic encryption with multiple passes for security
  let encrypted = new Uint8Array(plain);
  for (let pass = 0; pass < 3; pass++) {
    const passTable = generateSubstitutionTable(password + pass, saltString, imageHash, 3);
    encrypted = monoalphabeticEncrypt(encrypted, passTable);
  }

  const MAGIC = new TextEncoder().encode("MONOIMG1");
  const originalType = new TextEncoder().encode(file.type.padEnd(16, '\0').substring(0, 16));
  
  const imageHashBytes = new TextEncoder().encode(imageHash.padEnd(64, '\0').substring(0, 64));
  const header = new Uint8Array(8 + 16 + 16 + 64 + 4); // magic + originalType + salt + imageHash + length
  header.set(MAGIC, 0);
  header.set(originalType, 8);
  header.set(salt, 24);
  header.set(imageHashBytes, 40);
  
  // Store cipher data length in header for exact extraction
  const lengthBytes = new Uint8Array(4);
  lengthBytes[0] = (encrypted.length >> 24) & 0xFF;
  lengthBytes[1] = (encrypted.length >> 16) & 0xFF;
  lengthBytes[2] = (encrypted.length >> 8) & 0xFF;
  lengthBytes[3] = encrypted.length & 0xFF;
  header.set(lengthBytes, 104); // Updated position after adding imageHash

  // Combine header + encrypted data
  const encryptedData = new Uint8Array(header.length + encrypted.length);
  encryptedData.set(header, 0);
  encryptedData.set(encrypted, header.length);

  return await encryptedDataToPNG(encryptedData);
}

/* ======== Enhanced Monoalphabetic File Decryption ======== */
async function decryptFile(file, password){
  try {
    const encryptedData = await pngToEncryptedData(file);
    
    if (encryptedData.length < 108) {
      throw new Error("❌ Invalid encrypted file - file too small or corrupted");
    }
    
    // Verify magic header for monoalphabetic format
    const MAGIC = new TextEncoder().encode("MONOIMG1");
    for(let i = 0; i < MAGIC.length; i++){ 
      if(encryptedData[i] !== MAGIC[i]) {
        throw new Error("❌ This is not a valid monoalphabetic encrypted image file. Please select a PNG file that was encrypted by this app."); 
      }
    }

    const originalTypeBytes = encryptedData.slice(8, 24);
    const originalType = new TextDecoder().decode(originalTypeBytes).replace(/\0/g, '');
    
    const salt = encryptedData.slice(24, 40);
    const saltString = Array.from(salt).map(b => b.toString(16).padStart(2, '0')).join('');
    
    const imageHashBytes = encryptedData.slice(40, 104);
    const imageHash = new TextDecoder().decode(imageHashBytes).replace(/\0/g, '');
    
    // Read the exact cipher data length
    const cipherLength = (encryptedData[104] << 24) | (encryptedData[105] << 16) | (encryptedData[106] << 8) | encryptedData[107];
    const cipherBytes = encryptedData.slice(108, 108 + cipherLength); // Updated slice position

    if (cipherBytes.length === 0 || cipherBytes.length !== cipherLength) {
      throw new Error("❌ Corrupted encrypted file - cipher data mismatch");
    }

    // Apply reverse monoalphabetic decryption (3 passes in reverse order)
    let decrypted = new Uint8Array(cipherBytes);
    for (let pass = 2; pass >= 0; pass--) {
      const passTable = generateSubstitutionTable(password + pass, saltString, imageHash, 3);
      const reverseTable = generateReverseTable(passTable);
      decrypted = monoalphabeticDecrypt(decrypted, reverseTable);
    }
    
    if (decrypted.length === 0) {
      throw new Error("🔑 Wrong password - unable to decrypt image data");
    }
    
    return new Blob([decrypted], { type: originalType || "image/jpeg" });
    
  } catch (error) {
    if (error.message.includes("Invalid encrypted file") || error.message.includes("monoalphabetic")) {
      throw new Error("❌ This is not a valid monoalphabetic encrypted image file. Please select a PNG file that was encrypted by this app.");
    } else if (error.message.includes("Wrong password")) {
      throw new Error("🔑 Incorrect password! Please check your password and try again.");
    } else if (error.message.includes("Corrupted")) {
      throw new Error("💥 The encrypted file appears to be corrupted or damaged. Try re-encrypting the original image.");
    } else {
      throw new Error(`❌ Decryption failed: ${error.message}`);
    }
  }
}

/* ======== UI Event Handlers ======== */
const modeSel = document.getElementById("mode");
const fileInput = document.getElementById("fileInput");
const keyInput = document.getElementById("key");
const goBtn = document.getElementById("goBtn");
const preview = document.getElementById("preview");
const centralToggle = document.getElementById('centralToggle');
const turnOnDiv = document.getElementById('turnon');
let lightsOn = false;

/* Combined toggle function for both button and lamp */
function toggleLights() {
  lightsOn = !lightsOn;
  
  if (lightsOn) {
    turnOnDiv.classList.add('lights-on');
    centralToggle.classList.add('lights-on');
    centralToggle.textContent = '🔆';
  } else {
    turnOnDiv.classList.remove('lights-on');
    centralToggle.classList.remove('lights-on');
    centralToggle.textContent = '💡';
  }
}

/* Use the combined toggle function for button click */
centralToggle.addEventListener('click', toggleLights);

goBtn.addEventListener("click", async () => {
  const mode = modeSel.value;
  const file = fileInput.files[0];
  const password = keyInput.value;

  // Validation
  if(!mode) { setStatus("⚠️ Please select an operation mode", "warning"); return; }
  if(!file) { setStatus("⚠️ Please upload an image file", "warning"); return; }
  if(!password) { setStatus("⚠️ Please enter a secret password", "warning"); return; }
  if(password.length < 6) { setStatus("⚠️ Password must be at least 6 characters", "warning"); return; }

  goBtn.disabled = true;
  preview.style.display = "none";

  try {
    if(mode === "encrypt") {
      setStatus("🔒 Encrypting your image...", "loading");
      const startTime = Date.now();
      
      const encryptedBlob = await encryptFile(file, password);
      const duration = ((Date.now() - startTime) / 1000).toFixed(1);
      
      preview.src = URL.createObjectURL(encryptedBlob);
      preview.style.display = "block";
      preview.style.imageRendering = "pixelated"; // Show encrypted noise pattern clearly
      preview.style.border = "2px solid rgba(255, 235, 131, 0.3)"; // Golden border for encrypted images
      
      const fileSizeKB = (encryptedBlob.size / 1024).toFixed(1);
      setStatus(`✅ Image encrypted successfully in ${duration}s! Encrypted as visible PNG (${fileSizeKB}KB) with secure noise pattern.`, "success");
      downloadBlob(encryptedBlob, `encrypted_${file.name.split('.')[0]}.png`);
      
    } else if(mode === "decrypt") {
      setStatus("🔓 Decrypting your image...", "loading");
      const startTime = Date.now();
      
      const decryptedBlob = await decryptFile(file, password);
      const duration = ((Date.now() - startTime) / 1000).toFixed(1);
      
      preview.src = URL.createObjectURL(decryptedBlob);
      preview.style.display = "block";
      preview.style.imageRendering = "auto"; // Smooth rendering for original images
      preview.style.border = "2px solid rgba(72, 187, 120, 0.3)"; // Green border for decrypted images
      
      const fileSizeKB = (decryptedBlob.size / 1024).toFixed(1);
      setStatus(`🎉 Image decrypted successfully in ${duration}s! Original image restored (${fileSizeKB}KB).`, "success");
      downloadBlob(decryptedBlob, `decrypted_${file.name}`);
    }
  } catch(err) {
    console.error("Encryption/Decryption error:", err);
    setStatus(err?.message || "❌ Operation failed - please try again", "error");
    preview.style.display = "none";
  } finally {
    goBtn.disabled = false;
  }
});

// Dynamic label updates
modeSel.addEventListener("change", () => {
  const label = document.getElementById("fileLabel");
  keyInput.value = ""; // Clear secret password
  fileInput.value = ""; // Clear file upload
  preview.style.display = "none"; // Hide preview
  document.getElementById("status").textContent = ""; // Clear status
  
  if(modeSel.value === "encrypt") {
    label.textContent = "Upload Original Image (PNG/JPG):";
    fileInput.accept = ".png,.jpg,.jpeg,image/png,image/jpeg";
  } else if(modeSel.value === "decrypt") {
    label.textContent = "Upload Encrypted PNG Image:";
    fileInput.accept = ".png,image/png";
  } else {
    label.textContent = "Upload Image (PNG/JPG):";
    fileInput.accept = ".png,.jpg,.jpeg,image/png,image/jpeg";
  }
});

// File drag and drop support
['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
  fileInput.addEventListener(eventName, preventDefaults, false);
});

function preventDefaults(e) {
  e.preventDefault();
  e.stopPropagation();
}

fileInput.addEventListener('drop', handleDrop, false);

function handleDrop(e) {
  const dt = e.dataTransfer;
  const files = dt.files;
  fileInput.files = files;
}
</script>

</body>
</html>
